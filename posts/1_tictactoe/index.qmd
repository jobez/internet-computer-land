---
title: "bitwise tictactoe"
---

```{ojs}
//| echo: false
contract = {
var abi = await FileAttachment("tictactoe_abi.json").json()
return wallet ? (new starknetjs.Contract(abi, "0x02d73095244b035d7eae13918444cf9938ad7cf0c1a985e13d927ca670c2b111",
wallet.account)) : null

}
```



```{ojs}
//| panel: sidebar
//| echo: false

import { connectWallet, starknetjs  } from "/posts/0_hello_wallet/index.qmd";
d3 = require("d3@6");

viewof wallet = Inputs.button("Connect", {value: null, reduce: connectWallet})

viewof game_id = Inputs.range([1, 255], {step: 1, label: "Game Id"})

async function createGame(v) {
    var txn = await contract.init_new_game()
    console.log(txn);
    return txn;

}

async function joinGame(v) {
    console.log(game_id);
    var txn = await contract.join_game(game_id)
    console.log(txn);
    return txn;

}

viewof txn_state = Inputs.button([
  ["Create", createGame],
  ["Join", joinGame],
  ["Submit move", value => console.log("submit")]  

], {value: null, label: "Game"})

```


::: {.panel-tabset}
## game

```{ojs}
//| echo: false
__card = renderGame()
```

## debugging

```{ojs}
wallet.selectedAddress

```

```{ojs}
c_game_state
```
```{ojs}
role
```

```{ojs}
txn_state

```

```{ojs}
 txn_status = null // pollTxn(txn_state, 1000)
```

```{ojs}
c_game_state = {
     if (contract) {
       let game_id = await contract.player_to_game_id(wallet.selectedAddress); 
       let game_state = await contract.game_id_to_game(game_id.game_idx)
       return [game_id.game_idx, game_state.game]
    }

}
```







```{ojs}
role = {

    let hex_address_o = starknetjs.number.toHex(c_game_state[1].player_o).toString().slice(2);
    let hex_address_x = starknetjs.number.toHex(c_game_state[1].player_x).toString().slice(2);
    let formatted_addr = wallet.selectedAddress.slice(3);
    console.log(hex_address_x, hex_address_o, formatted_addr);
    if (hex_address_o == formatted_addr) {
        return "O";
        
    } 
    
    if (hex_address_x == formatted_addr) {
        return "X";
    }
    
    return "NONE";

}
```

```{ojs}
contract
```

```{ojs}
wallet
```
:::


## tic tac toe

There is a cool solidity tutorial that goes through implementing [tictactoe](https://book.tictactoken.co/) which inspired me to try to do a tictactoe web client and cairo/starknet contract.

There was [an excellent observablehq notebook](https://observablehq.com/@alaricmoore/tic-tac-toe)  that I am only slightly editing here. It really demonstrates observablehq's really elegant async abstractions, [generators](https://observablehq.com/@observablehq/introduction-to-generators).

I won't go to into them here, but I am hopeful/curious about whether these abstractions can give good flexibility in working with the inherently asynchronous nature of blockchain interaction.

## whats in a game?

How do we represent a game of tictactoe?

```
struct Game {
    player_x: felt,
    player_o: felt,
    state_x: felt,
    state_o: felt,
    completed: felt,
}
```

```{ojs}
async function* pollTxn(tx, timeout) {
 while(true) {
  var last_response = ''; 
  let receipt = await wallet.provider.getTransactionReceipt(tx.transaction_hash)
  if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {
    return receipt;
  } else {
    await Promises.delay(timeout);
    if (last_response != receipt.status) {
    yield receipt;
    }
    last_response = receipt.status;
   
  }
  }
}
```


### coordinating game session

A game needs two players. Since the game is going to be played 'across' a contract, we need to allow one player to create and invite another player to a game.


```{ojs}
async function* renderGame() {
  const state = createState();
  while (true) {
    let body = null;
    const p = new Promise((resolve) => {
      body = renderGrid(state, resolve);
    });

    yield body;
    await p;
  }
}
```

```{ojs}
function renderBox(cellValue, onClick) {
  //const charLut = [``, X_PLAYER, O_PLAYER];
  // const charLut = ['', 'X', 'O']; 
  const box = html`
    <div
      style="
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100px;
        height: 100px;
        border: 2px black solid;
        user-select: none;
      ">
     <div style="font-size: 5em">${charLut[cellValue]}</div>
  </div>`;

  box.addEventListener("click", onClick);
  //render box cares not about what the clicking does
  return box;
}
```

```{ojs}

renderGrid = (state, onChange) =>
  html`
  <div style="display:flex; flex-direction: column; justify-content: center; align-items: center;">
    <h1 style="font-size: 5em;color: red">Tic-Tac-Toe</h1>
    <h2> Winner is ${charLut[state.winner]}</h2> 
    <div style="
      display:inline-flex;
      justify-content: center;
      align-items: center;
      border: 2px solid black;
    ">${d3.range(GRID_WIDTH).map((row) => {
      return html`<div>${d3.range(GRID_HEIGHT).map((col) =>
        renderBox(state.board[col][row], () => {
          handleTurn(state, col, row); //state[col][row] = (state[col][row] + 1) % 3;
          onChange();
          //}
        })
      )}`;
    })}
    </div>
  </div>`

```

```{ojs}
function cr_to_binary(col, row) {
    var increase;
    switch (col) {
        case 0: 
            increase = 0;
            break;
        case 1:
            increase = 3;
            break;
        case 2:
            increase = 6
;

    }
    
    var binary_idx = row + increase;
    return Math.pow(2, binary_idx);
}
```

```{ojs}
function handleTurn(state, col, row) {
  if (state.board[col][row] === 0) {
    if (state.turn % 2 === 0) {
      state.board[col][row] = X_PLAYER;
      state.my_potential_move = [ cr_to_binary(col, row)  , [col, row] ]

    } else {
      state.board[col][row] = O_PLAYER;
      state.my_potential_move = [ cr_to_binary(col, row)  , [col, row] ]
    }
    state.turn++;
    // winGame(state);
    console.log(state, col, row);
  } else {
    let bival = state.my_potential_move[0];
    let [p_c, p_r] = state.my_potential_move[1]
    if (p_c == col && p_r == row) {
    state.my_potential_move = null;
    state.board[col][row] = 0;
     
     }

  }
}

```

```{ojs}
charLut = ["", "X", "O", "neither"]
```

```{ojs}
createState = () => {
  const board = d3
    .range(GRID_HEIGHT)
    .map(() => d3.range(GRID_WIDTH).map(() => 0));
  //state[2][2] = 1;
  return { board, turn: 0, winner: 0, x_player_state: 0, o_player_state: 0, my_potential_move: null };
}
```

```{ojs}
//| echo: false
GRID_WIDTH = 3
GRID_HEIGHT = 3
X_PLAYER = 1
X_PLAYER_STATE = 0
O_PLAYER = 2
O_PLAYER_STATE = 0
NEITHER = 3
```
