[
  {
    "objectID": "posts/1_tictactoe/index.html",
    "href": "posts/1_tictactoe/index.html",
    "title": "bitwise tictactoe",
    "section": "",
    "text": "contract = {\nvar abi = await FileAttachment(\"tictactoe_abi.json\").json()\nreturn wallet ? (new starknetjs.Contract(abi, \"0x02a21ef6a5f000e6647857c88b46a66c54df282d88ca6be7d86079672e5f51b4\",\nwallet.account)) : null\n\n}"
  },
  {
    "objectID": "posts/1_tictactoe/index.html#tic-tac-toe",
    "href": "posts/1_tictactoe/index.html#tic-tac-toe",
    "title": "bitwise tictactoe",
    "section": "tic tac toe",
    "text": "tic tac toe\nNOTE: the above UI is coded against a locally deployed contract. I’ll remove this note when I deployed to a publicly available testnet.\nThere is a cool solidity tutorial that goes through implementing tictactoe which inspired me to try to do a tictactoe web client and cairo/starknet contract.\nThere was an excellent observablehq notebook that I am only slightly editing here. It really demonstrates observablehq’s really elegant async abstractions, generators.\nI’ll be referencing my cairo code as of this commit."
  },
  {
    "objectID": "posts/1_tictactoe/index.html#whats-in-a-game",
    "href": "posts/1_tictactoe/index.html#whats-in-a-game",
    "title": "bitwise tictactoe",
    "section": "whats in a game?",
    "text": "whats in a game?\nHow do we represent a game of tictactoe?\nstruct Game {\n    player_x: felt,\n    player_o: felt,\n    state_x: felt,\n    state_o: felt,\n    last_mover: felt,\n    winner: felt,\n}\n\nEach role (X and O), to be assigned to a player, needs a player to interact with the contract via an account so we can assign an address for a role.\nMethods ‘exposed’ for account interaction are tagged with external in cairo and you can use get_caller_address to get the address intrinsic to the interaction. We have two external methods exposed for users to create and join games.\n@external\nfunc init_new_game{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() {\n   let address : felt = get_caller_address();     \n   let game_idx : felt = game_count.read();\n\n   assert_not_zero(address);     \n    \n   let potential_game_idx : felt = player_to_game_idx.read(address);\n \n   with_attr error_message (\"a player can only have one active game\") {\n        assert potential_game_idx = 0;\n   }\n\n %{ print(f\"passing value: {ids.address=} {ids.game_idx=} \") %}\n   let new_game : Game = Game(address, 0, 0, 0, 0, 0);\n    \n   game_state.write(game_idx+1, new_game);\n   player_to_game_idx.write(address, game_idx+1); \n   game_count.write(game_idx+2); \n\n   return (); \n}\nWe need to keep track of game_count so we can establish identifiers for games upon initialization in init_game and that identifier is used as an argument in join_game.\n@external\nfunc join_game{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_idx: felt){\n   let address : felt = get_caller_address();\n   let game : Game = game_state.read(game_idx);\n   with_attr error_message (\"a game must exist to join\") {\n       assert_not_zero(game.player_x);\n   }\n\n    with_attr error_message (\"you cannot join the same game\") {\n       assert_not_equal(game.player_x, address);\n   }\n\n   with_attr error_message (\"a spot must be available to join\") {\n       assert game.player_o = 0;\n   }\n\n   let joined_game : Game = Game(game.player_x, address, game.state_x, game.state_o, game.last_mover, game.winner);\n   game_state.write(game_idx, joined_game); \n  player_to_game_idx.write(address, game_idx);\n\n   return (); \n}\nEach role has its own state. The state is encoded into an integer, where the value represents the X or O move on a tictactoe board. Each ‘spot’ on the board (counted from 0 to 8) is treated as power of two.\nWe check for state of each player for a win state by encoding the winning configurations in their representation and ’bitwise_and` the state against a winning state. If the result of that bitwise_and is the winning state, the player has won the game.\nfunc _check_winner{bitwise_ptr: BitwiseBuiltin*}(state: felt, idx: felt, winners: felt*) -> felt {\n    let win_state : felt = [winners];\n    \n    let win_check : felt = bitwise_and(state, win_state);\n\n    %{ print(f\"passing value: {ids.state=} {ids.win_state=} {ids.win_check=}\") %}\n    if (win_check == win_state) {\n       return 1; \n    }\n\n    if (idx == 0) {\n       return (0); \n    } else {\n       let result : felt =  _check_winner(state=state, idx=idx-1, winners=winners+1);\n       return (result); \n    }\n   \n}\n\nfunc check_winner{bitwise_ptr: BitwiseBuiltin*}(state: felt) -> felt {\n    alloc_locals;\n    let winners: felt* = alloc();\n\n    assert winners[0] = 448; \n    // 111 000 000\n    assert winners[1] = 56;\n    // 000 111 000\n    assert winners[2] = 7;\n    // 000 000 111\n    assert winners[3] = 292;\n    // 100 100 100\n    assert winners[4] = 146;\n    // 010 010 010\n    assert winners[5] = 73;\n    // 001 001 001\n    assert winners[6] = 273;\n    // 100 010 001\n    assert winners[7] = 84;\n    // 001010100\n\n    let res : felt = _check_winner(state=state, idx=7, winners=winners);\n    return (res);\n\n}\nThis check_winner logic is part of the overall logic in make_move. Note that if you interact with this contract outside the client, since there isn’t sanity checking that a player makes a valid move from one move to the next. This means if there was any stakes involved in this contract, smart people will just spam the contract with winning game states and disgruntled people will look to publicly spank me.\n@external\nfunc make_move{syscall_ptr : felt*, bitwise_ptr: BitwiseBuiltin*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_idx: felt, updated_game_state : felt) {\n   alloc_locals;\n   let address : felt = get_caller_address();     \n   assert_not_zero(address);     \n   let game : Game = game_state.read(game_idx); \n   let role : felt = derive_address_role(game, address);\n   \n    \n    enforce_permissable_move(role, game);\n\n    let (new_game : Game, game_over : felt) = update_game(role, game, updated_game_state);\n\n    game_state.write(game_idx, new_game);   \n    \n    handle_end_game(game_over, address, role, game_idx, new_game);\n    \n\n    return ();\n\n}\nWe need to derive the role of player in the game from address via derive_address_role This function also gives us an error if the actor interacting with the contract doesn’t belong to the denoted game at all:\nfunc derive_address_role(game : Game, address : felt) -> felt {\n    if (address == game.player_x) {\n        return (PLAYER_X);\n    \n    }\n\n    if (address == game.player_o) {\n        return (PLAYER_O);\n        \n    }\n\n   with_attr error_message (\"this player is not registered in this game\") {\n        assert 1 = 0;\n   }    \n   \n   return (0); \n\n}\nIn the case the address has a role in the game, we check to see if it is the players turn.\nfunc enforce_permissable_move(role: felt, game: Game) {\n\n   with_attr error_message (\"not your turn\") {\n      assert_not_equal(role, game.last_mover);\n   }\n\n   with_attr error_message (\"game over\") {\n      assert game.winner = 0;\n   }    \n\n    return ();\n}\nAll that safe-guarding out of the way, we update the game and check if the player has made a winning move.\nfunc update_game{bitwise_ptr: BitwiseBuiltin*}(role : felt, prior_game : Game, new_move :felt) -> (new_game: Game, end_game: felt) {\n    if (role == PLAYER_X) {\n       let winning_move = check_winner(new_move); \n       let maybe_won = winning_move * role; \n       let new_game = Game(prior_game.player_x, prior_game.player_o, new_move, prior_game.state_o, PLAYER_X, maybe_won);\n       return (new_game=new_game, end_game=winning_move);\n    } else {\n       let winning_move = check_winner(new_move); \n       let maybe_won = winning_move * role;\n       let new_game = Game(prior_game.player_x, prior_game.player_o, prior_game.state_x, new_move, PLAYER_O, maybe_won);\n       return (new_game=new_game, end_game=winning_move);\n    }\n\n}\nThe handle_end_game function releases a player from being associatted with completed games, as well as emiting a game over event. The tempvar stuff is incidental complexity in the cairo vm involving how it tracks references (perhaps to be expanded in another post).\nfunc handle_end_game{ syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_ended : felt, maybe_winner : felt, maybe_winner_role : felt, game_id : felt, game : Game) {\n    if (game_ended == 0) {\n    tempvar syscall_ptr=syscall_ptr;\n    tempvar pedersen_ptr=pedersen_ptr;\n    tempvar range_check_ptr=range_check_ptr;\n    \n    } else {\n    player_to_game_idx.write(game.player_x, 0);\n    player_to_game_idx.write(game.player_o, 0);\n    game_over.emit(game_id=game_id, role=maybe_winner_role, winner=maybe_winner);\n    tempvar syscall_ptr=syscall_ptr;\n    tempvar pedersen_ptr=pedersen_ptr;\n    tempvar range_check_ptr=range_check_ptr;    \n    \n    } \n\n    \n    return ();\n}\nThe game_over event gives a client a way to know that a given move ends the game. This happens when a user submits a transaction and we query for a receipt of the transaction. Events are communicated in the receipt of transactions and obtusely look something like this:\n{\"execution_resources\": {\"n_memory_holes\": 46, \"n_steps\": 1036, \"builtin_instance_counter\": {\"pedersen_builtin\": 4, \"range_check_builtin\": 15, \"bitwise_builtin\": 6, \"ecdsa_builtin\": 1}}, \"actual_fee\": \"0x4052f28072000\", \"block_hash\": \"0x11\", \"block_number\": 17, \"events\": [{\"keys\": [\"0xdabba9ce03ade36611d5d401193a84cd9e1d9ee37a87ce9bbab55690fcfae0\"], \"from_address\": \"0x2a21ef6a5f000e6647857c88b46a66c54df282d88ca6be7d86079672e5f51b4\", \"data\": [\"0x1\", \"0x1\", \"0x38aa61d589ed7010703ec364fa37a474b7c66b4079579ff472d65731919dfdf\"]}, {\"keys\": [\"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"], \"from_address\": \"0x62230ea046a9a5fbc261ac77d03c8d41e5d442db2284587570ab46455fd2488\", \"data\": [\"0x38aa61d589ed7010703ec364fa37a474b7c66b4079579ff472d65731919dfdf\", \"0x388ca486b82e20cc81965d056b4cdcaacdffe0cf08e20ed8ba10ea97a487004\", \"0x4052f28072000\", \"0x0\"]}], \"status\": \"ACCEPTED_ON_L2\", \"transaction_index\": 0, \"transaction_hash\": \"0x2e1d29606ae45b8ed95b598a20e337bea7a9ac92fae6dde10527daab4a1ee14\", \"l2_to_l1_messages\": []}\nThe ‘keys’ of events can be derived like so:\n\nselector_name = starknetjs.hash.getSelectorFromName(\"game_over\");\nselector_name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewing a conttract\nThe view logic here might be a little too complex. Essentially it is one render loop that uses observablehq primitives. We get the state of a given game, the client state of the view, and pass it to render logic. If we have a pendingTxn in state, we get the receipt, then rerender, or we just wait 3 seconds and rerender.\n\nasync function* renderGame() {\n  const viewState = createState();\n  var contractState = [starknetjs.number.toBN(0), {}, -1];  \n  while (true) {\n    let body = null;\n    \n    const p = new Promise(async (resolve) => {\n      console.log(\"about to render\", contractState, viewState);\n      body = renderGrid(contractState, viewState, resolve);\n      contractState = await fetchContractState();\n      if (contract) {\n      \n      if(viewState.pendingTxn) {\n      \n         await handleTxn(viewState)  \n         resolve() \n      \n      } else {\n      \n      await Promises.delay(3000);\n      resolve();\n      \n      }\n      }\n    });\n\n    yield body;\n\n    await p;\n  }\n}\n\n\n\n\n\n\n\nasync function handleTxn(state) {\n    let txnHash = state.pendingTxn.transaction_hash;\n    let receipt =  await wallet.provider.getTransactionReceipt(txnHash);\n    if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {\n\n        state.pendingTxn = null;\n        // state.txnState = null;\n    \n    } else {\n    \n        state.txnState = receipt;\n        console.log(receipt);\n    \n    }\n    \n\n\n}\n\n\n\n\n\n\n\nfunction renderBox(contractState, cr, cellValue, onClick) {\n     let boardState = contractState[1];\n     let xState = boardState.state_x;\n     let oState = boardState.state_o;\n     let binaryRep = cr_to_binary(cr[0], cr[1]);\n     let maybeX = xState & binaryRep;\n     let maybeO = oState & binaryRep;\n\n    if (maybeX == binaryRep) {\n        cellValue = 1;\n    }\n    if (maybeO == binaryRep) {\n        cellValue = 2;\n    }\n \n\n \n  \n  const box = html`\n    <div\n      style=\"\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 100px;\n        height: 100px;\n        border: 2px black solid;\n        user-select: none;\n      \">\n     <div style=\"font-size: 5em\">${charLut[cellValue]}</div>\n  </div>`;\n\n  box.addEventListener(\"click\", onClick);\n\n  //render box cares not about what the clicking does\n  return box;\n}\n\n\n\n\n\n\n\nfunction boardStateForRole(role, contractState) {\n    let boardState = undefined;\n    if (role == 1) {\n    \n        boardState = contractState.state_x\n        \n    } else if (role == 2) {\n    \n        boardState = contractState.state_o\n    \n    }\n    \n    return boardState;\n}\n\n\n\n\n\n\n\ntxnView = (contractState, viewState) => {\n    if (viewState.pendingTxn) {\n    \n    return html`<div>Txn: ${viewState.pendingTxn.transaction_hash} Current status: ${viewState.txnState ? viewState.txnState.status : \"pending\"}</div>`\n    \n    } else {\n    \n      return \"\";  \n    }\n}\n\n\n\n\n\n\n\nturnView = (contractState, viewState) => {\n    let ourTurn = contractState[3];\n    return html`<div>${ourTurn ? \"Your turn.\" : \"Their turn\"}</div>`\n\n}\n\n\n\n\n\n\n\nrenderGrid = (contractState, state, onChange) => {\n  let button = html`<button>Submit move</button>`\n\n  let submitMove = async (e) => {\n     let gameId = contractState[0].toNumber();\n     let role = contractState[2];\n     let moveToSubmit = state.my_potential_move[0];\n     let boardState = boardStateForRole(role, contractState[1]); \n     let playerTotalBoardState = moveToSubmit + boardState;\n     let txn = await contract.make_move(gameId, playerTotalBoardState);\n     state.pendingTxn = txn\n     onChange();\n  }\n  button.addEventListener(\"click\", submitMove)\n  \n  let txnViewer = txnView(contractState, state);\n  return html`\n  <div style=\"display:flex; flex-direction: column; justify-content: center; align-items: center;\">\n    <h1 style=\"font-size: 5em;color: red\">Tic-Tac-Toe</h1>\n    <h2> Winner is ${charLut[state.winner]}</h2> \n    <h4>Current Game Id : ${contractState[0].toNumber()}</h2>\n    ${button}\n    ${txnViewer}\n    ${turnView(contractState, state)}\n    <div style=\"\n      display:inline-flex;\n      justify-content: center;\n      align-items: center;\n      border: 2px solid black;\n    \">${d3.range(GRID_WIDTH).map((row) => {\n      return html`<div>${d3.range(GRID_HEIGHT).map((col) =>\n        renderBox(contractState, [col, row], state.board[col][row], () => {\n          handleTurn(contractState, state, col, row); \n          onChange();\n          //}\n        })\n      )}`;\n    })}\n    </div>\n  </div>`\n  }\n\n\n\n\n\n\n\nfunction cr_to_binary(col, row) {\n    var increase;\n    switch (col) {\n        case 0: \n            increase = 0;\n            break;\n        case 1:\n            increase = 3;\n            break;\n        case 2:\n            increase = 6\n;\n\n    }\n    \n    var binary_idx = row + increase;\n    return Math.pow(2, binary_idx);\n}\n\n\n\n\n\n\n\nfunction handleTurn(contractState, state, col, row) {\n  let role = contractState[2];\n\n  if (state.board[col][row] === 0) {\n      state.board[col][row] = role;\n      state.my_potential_move = [ cr_to_binary(col, row)  , [col, row] ]\n\n\n    state.turn++;\n    // winGame(state);\n    console.log(state, col, row);\n  } else {\n    let bival = state.my_potential_move[0];\n    let [p_c, p_r] = state.my_potential_move[1]\n    if (p_c == col && p_r == row) {\n    state.my_potential_move = null;\n    state.board[col][row] = 0;\n     \n     }\n\n  }\n}\n\n\n\n\n\n\n\ncharLut = [\"\", \"X\", \"O\", \"neither\"]\n\n\n\n\n\n\n\ncreateState = () => {\n  const board = d3\n    .range(GRID_HEIGHT)\n    .map(() => d3.range(GRID_WIDTH).map(() => 0));\n  //state[2][2] = 1;\n  return { board, turn: 0, winner: 0, x_player_state: 0, o_player_state: 0, my_potential_move: null, pendingTxn: null, txnState: null };\n}\n\n\n\n\n\n\n\nGRID_WIDTH = 3\nGRID_HEIGHT = 3\nX_PLAYER = 1\nX_PLAYER_STATE = 0\nO_PLAYER = 2\nO_PLAYER_STATE = 0\nNEITHER = 3"
  },
  {
    "objectID": "posts/0_hello_wallet/index.html",
    "href": "posts/0_hello_wallet/index.html",
    "title": "hello, wallet",
    "section": "",
    "text": "communication between users, applications, blockchains\nA wallet gives a user an account on a given blockchain. But implicitly it offers a way for users to communicate with it.\nHow?\nLet’s investigate our wallet object again.\n\nwallet\n\n\n\n\n\n\nWhat are these attributes of account and provider?\nA provider lets you interact with the network without signing transactions, which basically means it gives you read access.\nWhen we want write access, we communicate with our account to, in Starknet’s case, the sequencer node.\nBut how is this communication done?\nWe can be so bold as to look at starknetjs source and see that the provider object using an rpc protocol against the provider endpoint.\nSame deal with the sequencer, but it also seems that some functionality is exposed as http endpoints, i.e. callContract\nSo let’s try to follow what is happening when a user interacts with a contract on a web client.\nEssentially, starknet-js takes ownership of coordinating users to the right remote calls. In a mature blockchain ecologies, the remote calls are to an open class of processes, where processes can perform certain roles like having access to the full history of blockchain transactions or simply accepting/relaying transactions and participating in consensus.\nSo when I click the increment button and get back a transaction hash, the user’s action/agency is given an identifiable ticket in a queue of transactions that need to make it to a block for it to be finalized.\nA couple things stand out–one, is that ‘reads’ from a contract need to have some awareness of the state of users transactions of the contract at the very least, let alone the possible transactions of other users. This is something I’ll explore in subsequent posts.\nI am still unsure how well observablehq’s reactive constructs will play with ‘hooking’ into a blockchain contracts. The allure of starting out with it is offers me more joy than the full gamut react or whatever hell else is popular in js land.\nWe will see if there’s a hard limit.\nAnother is, having had a little experience with the early nft wave of Solana, when you are so lucky to have a ‘surge’ of users trying to submit transactions against the same node/rpc, you aren’t going to have a good time. There were a lot of cases of quiet failure.\nSo the question of the best of all ways to provide your users the smoothest experience with a blockchain might involve a little devops.\nOnward."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "internet computer land",
    "section": "",
    "text": "No matching items"
  }
]