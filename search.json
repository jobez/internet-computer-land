[
  {
    "objectID": "posts/0_hello_wallet/index.html",
    "href": "posts/0_hello_wallet/index.html",
    "title": "hello, wallet",
    "section": "",
    "text": "I’ll start with a brief little ‘how to’ guide of building a ui that can ‘reach out’ to a browser extension wallet and then ‘do things with’ a contract on starknet. Then I’ll try to probe some of the theory of how that is happening.\nThere is a little bit of incidental detail that I’ll ellide here, as I am using Quarto which (in turn) lets me use observable for computation. We can kind of squint and treat it as ‘just’ javascript and I’ll defer all the details on how it isn’t to the creators here.\nWe will see how well observable plays with contract interop. Here we only break a little ground and in subsequent iterations.\nSo we start by pulling in starknetjs and get_starknet\n\nstarknetjs = import(\"https://jspm.dev/starknet\")\nget_starknet = import(\"https://jspm.dev/get-starknet\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThen we write a async function that uses get_starknet to display to a user an interface for selecting and consenting a wallet and a given account to a session.\n\nasync function connectWallet(e)  {\n   var wallet =  await get_starknet.connect();\n   await wallet.enable();\n   return wallet;\n}\n\n\n\n\n\n\nAnd consider this some boiler plate for observable to give me a little button view that, on clicked, will present aforementioned wallet interface.\n\nwallet ? md`${wallet.selectedAddress}, you achieved things. You pushed through. You did it.` : md`Come on. All you need to do is install a browser plugin. You can do it.`\n\n\n\n\n\n\n\nviewof wallet = Inputs.button(\"Connect\", {value: null, reduce: connectWallet})\n\n\n\n\n\n\nIf you had the audacity to push through the resistance and actually install a browser plugin wallet, you can see that its object unifies a couple of abstractions we will get into in the question of how a client and contract on a chain interact: account and provider\n\nwallet\n\n\n\n\n\n\nWith a wallet, we can construct an interface to a contract that ‘lives’ on a chain. We also need said contracts abi which is the contract’s application binary interface and the contracts address.\nThe abi is constructed when you compile a cairo contract and the address is generated from the deployment of a contract to a chain.\n\ncontract = {\nvar abi = await FileAttachment(\"../counter_abi.json\").json()\nreturn wallet ? (new starknetjs.Contract(abi, \"0x036486801b8f42e950824cba55b2df8cccb0af2497992f807a7e1d9abd2c6ba1\", wallet.account)) : null\n\n}\n\n\n\n\n\n\nHere we call a view method, basically reading state from the contract. Observable has some magic that lets me treat promises like regular statements, but everything ‘across’ the contract interaction is asynchronous.\n\ncontract ? md`${contract.counter()} is the count` : null\n\n\n\n\n\n\nIncrement counter mutates the contract state.\n\nasync function callIncrement(e)  {\n   var txn = await contract.incrementCounter(1);\n   return txn;\n}\n\n\n\n\n\n\nInvoking it gives us an object with a transaction hash.\n\nviewof incrementTxn = Inputs.button(\"increment\", {value: null, reduce: callIncrement})\n\n\n\n\n\n\nWhat’s going on? What’s happening? What is this magic?\n\nincrementTxn\n\n\n\n\n\n\n\ncontract"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "internet computer land",
    "section": "",
    "text": "No matching items"
  }
]