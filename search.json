[
  {
    "objectID": "posts/1_tictactoe/index.html",
    "href": "posts/1_tictactoe/index.html",
    "title": "bitwise tictactoe",
    "section": "",
    "text": "contract = {\nvar abi = await FileAttachment(\"tictactoe_abi.json\").json()\nreturn wallet ? (new starknetjs.Contract(abi, \"0x02a21ef6a5f000e6647857c88b46a66c54df282d88ca6be7d86079672e5f51b4\",\nwallet.account)) : null\n\n}"
  },
  {
    "objectID": "posts/1_tictactoe/index.html#tic-tac-toe",
    "href": "posts/1_tictactoe/index.html#tic-tac-toe",
    "title": "bitwise tictactoe",
    "section": "tic tac toe",
    "text": "tic tac toe\nThere is a cool solidity tutorial that goes through implementing tictactoe which inspired me to try to do a tictactoe web client and cairo/starknet contract.\nThere was an excellent observablehq notebook that I am only slightly editing here. It really demonstrates observablehq’s really elegant async abstractions, generators.\nI won’t go to into them here, but I am hopeful/curious about whether these abstractions can give good flexibility in working with the inherently asynchronous nature of blockchain interaction."
  },
  {
    "objectID": "posts/1_tictactoe/index.html#whats-in-a-game",
    "href": "posts/1_tictactoe/index.html#whats-in-a-game",
    "title": "bitwise tictactoe",
    "section": "whats in a game?",
    "text": "whats in a game?\nHow do we represent a game of tictactoe?\nstruct Game {\n    player_x: felt,\n    player_o: felt,\n    state_x: felt,\n    state_o: felt,\n    completed: felt,\n}\n\nasync function handleTxn(state) {\n    let txnHash = state.pendingTxn.transaction_hash;\n    let receipt =  await wallet.provider.getTransactionReceipt(txnHash);\n    if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {\n\n        state.pendingTxn = null;\n        // state.txnState = null;\n    \n    } else {\n    \n        state.txnState = receipt;\n        console.log(receipt);\n    \n    }\n    \n\n\n}\n\n\n\n\n\n\n\nasync function* pollTxn(tx, timeout) {\n while(true) {\n  var last_response = ''; \n  let receipt = await wallet.provider.getTransactionReceipt(tx.transaction_hash)\n  if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {\n    return receipt;\n  } else {\n    await Promises.delay(timeout);\n    if (last_response != receipt.status) {\n    yield receipt;\n    }\n    last_response = receipt.status;\n   \n  }\n  }\n}\n\n\n\n\n\n\n\ncoordinating game session\nA game needs two players. Since the game is going to be played ‘across’ a contract, we need to allow one player to create and invite another player to a game.\n\nasync function* renderGame() {\n  const viewState = createState();\n  var contractState = [starknetjs.number.toBN(0), {}, -1];  \n  while (true) {\n    let body = null;\n    \n    const p = new Promise(async (resolve) => {\n      console.log(\"about to render\", contractState, viewState);\n      body = renderGrid(contractState, viewState, resolve);\n      contractState = await fetchContractState();\n      if (contract) {\n      \n      if(viewState.pendingTxn) {\n      \n         await handleTxn(viewState)  \n         resolve() \n      \n      } else {\n      \n      await Promises.delay(8000);\n      resolve();\n      \n      }\n      }\n    });\n\n    yield body;\n\n    await p;\n  }\n}\n\n\n\n\n\n\n\nfunction renderBox(contractState, cr, cellValue, onClick) {\n     let boardState = contractState[1];\n     let xState = boardState.state_x;\n     let oState = boardState.state_o;\n     let binaryRep = cr_to_binary(cr[0], cr[1]);\n     let maybeX = xState & binaryRep;\n     let maybeO = oState & binaryRep;\n\n    if (maybeX == binaryRep) {\n        cellValue = 1;\n    }\n    if (maybeO == binaryRep) {\n        cellValue = 2;\n    }\n \n\n \n  \n  const box = html`\n    <div\n      style=\"\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 100px;\n        height: 100px;\n        border: 2px black solid;\n        user-select: none;\n      \">\n     <div style=\"font-size: 5em\">${charLut[cellValue]}</div>\n  </div>`;\n\n  box.addEventListener(\"click\", onClick);\n\n  //render box cares not about what the clicking does\n  return box;\n}\n\n\n\n\n\n\n\nfunction boardStateForRole(role, contractState) {\n    let boardState = undefined;\n    if (role == 1) {\n    \n        boardState = contractState.state_x\n        \n    } else if (role == 2) {\n    \n        boardState = contractState.state_o\n    \n    }\n    \n    return boardState;\n}\n\n\n\n\n\n\n\ntxnView = (contractState, viewState) => {\n    if (viewState.pendingTxn) {\n    \n    return html`<div>Txn: ${viewState.pendingTxn.transaction_hash} Current status: ${viewState.txnState ? viewState.txnState.status : \"pending\"}</div>`\n    \n    } else {\n    \n      return \"\";  \n    }\n}\n\n\n\n\n\n\n\nturnView = (contractState, viewState) => {\n    let ourTurn = contractState[3];\n    return html`<div>${ourTurn ? \"Your turn.\" : \"Their turn\"}</div>`\n\n}\n\n\n\n\n\n\n\nrenderGrid = (contractState, state, onChange) => {\n  let button = html`<button>Submit move</button>`\n\n  let submitMove = async (e) => {\n     let gameId = contractState[0].toNumber();\n     let role = contractState[2];\n     let moveToSubmit = state.my_potential_move[0];\n     let boardState = boardStateForRole(role, contractState[1]); \n     let playerTotalBoardState = moveToSubmit + boardState;\n     let txn = await contract.make_move(gameId, playerTotalBoardState);\n     state.pendingTxn = txn\n     onChange();\n  }\n  button.addEventListener(\"click\", submitMove)\n  \n  let txnViewer = txnView(contractState, state);\n  return html`\n  <div style=\"display:flex; flex-direction: column; justify-content: center; align-items: center;\">\n    <h1 style=\"font-size: 5em;color: red\">Tic-Tac-Toe</h1>\n    <h2> Winner is ${charLut[state.winner]}</h2> \n    <h4>Current Game Id : ${contractState[0].toNumber()}</h2>\n    ${button}\n    ${txnViewer}\n    ${turnView(contractState, state)}\n    <div style=\"\n      display:inline-flex;\n      justify-content: center;\n      align-items: center;\n      border: 2px solid black;\n    \">${d3.range(GRID_WIDTH).map((row) => {\n      return html`<div>${d3.range(GRID_HEIGHT).map((col) =>\n        renderBox(contractState, [col, row], state.board[col][row], () => {\n          handleTurn(contractState, state, col, row); \n          onChange();\n          //}\n        })\n      )}`;\n    })}\n    </div>\n  </div>`\n  }\n\n\n\n\n\n\n\nfunction cr_to_binary(col, row) {\n    var increase;\n    switch (col) {\n        case 0: \n            increase = 0;\n            break;\n        case 1:\n            increase = 3;\n            break;\n        case 2:\n            increase = 6\n;\n\n    }\n    \n    var binary_idx = row + increase;\n    return Math.pow(2, binary_idx);\n}\n\n\n\n\n\n\n\nfunction handleTurn(contractState, state, col, row) {\n  let role = contractState[2];\n\n  if (state.board[col][row] === 0) {\n      state.board[col][row] = role;\n      state.my_potential_move = [ cr_to_binary(col, row)  , [col, row] ]\n\n\n    state.turn++;\n    // winGame(state);\n    console.log(state, col, row);\n  } else {\n    let bival = state.my_potential_move[0];\n    let [p_c, p_r] = state.my_potential_move[1]\n    if (p_c == col && p_r == row) {\n    state.my_potential_move = null;\n    state.board[col][row] = 0;\n     \n     }\n\n  }\n}\n\n\n\n\n\n\n\ncharLut = [\"\", \"X\", \"O\", \"neither\"]\n\n\n\n\n\n\n\ncreateState = () => {\n  const board = d3\n    .range(GRID_HEIGHT)\n    .map(() => d3.range(GRID_WIDTH).map(() => 0));\n  //state[2][2] = 1;\n  return { board, turn: 0, winner: 0, x_player_state: 0, o_player_state: 0, my_potential_move: null, pendingTxn: null, txnState: null };\n}\n\n\n\n\n\n\n\nGRID_WIDTH = 3\nGRID_HEIGHT = 3\nX_PLAYER = 1\nX_PLAYER_STATE = 0\nO_PLAYER = 2\nO_PLAYER_STATE = 0\nNEITHER = 3"
  },
  {
    "objectID": "posts/0_hello_wallet/index.html",
    "href": "posts/0_hello_wallet/index.html",
    "title": "hello, wallet",
    "section": "",
    "text": "communication between users, applications, blockchains\nA wallet gives a user an account on a given blockchain. But implicitly it offers a way for users to communicate with it.\nHow?\nLet’s investigate our wallet object again.\n\nwallet\n\n\n\n\n\n\nWhat are these attributes of account and provider?\nA provider lets you interact with the network without signing transactions, which basically means it gives you read access.\nWhen we want write access, we communicate with our account to, in Starknet’s case, the sequencer node.\nBut how is this communication done?\nWe can be so bold as to look at starknetjs source and see that the provider object using an rpc protocol against the provider endpoint.\nSame deal with the sequencer, but it also seems that some functionality is exposed as http endpoints, i.e. callContract\nSo let’s try to follow what is happening when a user interacts with a contract on a web client.\nEssentially, starknet-js takes ownership of coordinating users to the right remote calls. In a mature blockchain ecologies, the remote calls are to an open class of processes, where processes can perform certain roles like having access to the full history of blockchain transactions or simply accepting/relaying transactions and participating in consensus.\nSo when I click the increment button and get back a transaction hash, the user’s action/agency is given an identifiable ticket in a queue of transactions that need to make it to a block for it to be finalized.\nA couple things stand out–one, is that ‘reads’ from a contract need to have some awareness of the state of users transactions of the contract at the very least, let alone the possible transactions of other users. This is something I’ll explore in subsequent posts.\nI am still unsure how well observablehq’s reactive constructs will play with ‘hooking’ into a blockchain contracts. The allure of starting out with it is offers me more joy than the full gamut react or whatever hell else is popular in js land.\nWe will see if there’s a hard limit.\nAnother is, having had a little experience with the early nft wave of Solana, when you are so lucky to have a ‘surge’ of users trying to submit transactions against the same node/rpc, you aren’t going to have a good time. There were a lot of cases of quiet failure.\nSo the question of the best of all ways to provide your users the smoothest experience with a blockchain might involve a little devops.\nOnward."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "internet computer land",
    "section": "",
    "text": "No matching items"
  }
]