[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "internet computer land",
    "section": "",
    "text": "bitwise tictactoe\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nhello, wallet\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/1_tictactoe/index.html",
    "href": "posts/1_tictactoe/index.html",
    "title": "bitwise tictactoe",
    "section": "",
    "text": "contract = {\nvar abi = await FileAttachment(\"tictactoe_abi.json\").json()\nreturn wallet ? (new starknetjs.Contract(abi, \"0x02a21ef6a5f000e6647857c88b46a66c54df282d88ca6be7d86079672e5f51b4\",\nwallet.account)) : null\n\n}"
  },
  {
    "objectID": "posts/1_tictactoe/index.html#tic-tac-toe",
    "href": "posts/1_tictactoe/index.html#tic-tac-toe",
    "title": "bitwise tictactoe",
    "section": "tic tac toe",
    "text": "tic tac toe\nNOTE: the above UI is coded against a locally deployed contract. I’ll remove this note when I deployed to a publicly available testnet.\nThere is a cool solidity tutorial that goes through implementing tictactoe which inspired me to try to do a tictactoe web client and cairo/starknet contract.\nThere was an excellent observablehq notebook that I am only slightly editing here. It really demonstrates observablehq’s really elegant async abstractions, generators.\nI’ll be referencing my cairo code as of this commit."
  },
  {
    "objectID": "posts/1_tictactoe/index.html#whats-in-a-game",
    "href": "posts/1_tictactoe/index.html#whats-in-a-game",
    "title": "bitwise tictactoe",
    "section": "whats in a game?",
    "text": "whats in a game?\nHow do we represent a game of tictactoe?\nstruct Game {\n    player_x: felt,\n    player_o: felt,\n    state_x: felt,\n    state_o: felt,\n    last_mover: felt,\n    winner: felt,\n}\n\nEach role (X and O), to be assigned to a player, needs a player to interact with the contract via an account so we can assign an address for a role.\nMethods ‘exposed’ for account interaction are tagged with external in cairo and you can use get_caller_address to get the address intrinsic to the interaction. We have two external methods exposed for users to create and join games.\n@external\nfunc init_new_game{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}() {\n   let address : felt = get_caller_address();     \n   let game_idx : felt = game_count.read();\n\n   assert_not_zero(address);     \n    \n   let potential_game_idx : felt = player_to_game_idx.read(address);\n \n   with_attr error_message (\"a player can only have one active game\") {\n        assert potential_game_idx = 0;\n   }\n\n %{ print(f\"passing value: {ids.address=} {ids.game_idx=} \") %}\n   let new_game : Game = Game(address, 0, 0, 0, 0, 0);\n    \n   game_state.write(game_idx+1, new_game);\n   player_to_game_idx.write(address, game_idx+1); \n   game_count.write(game_idx+2); \n\n   return (); \n}\nWe need to keep track of game_count so we can establish identifiers for games upon initialization in init_game and that identifier is used as an argument in join_game.\n@external\nfunc join_game{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_idx: felt){\n   let address : felt = get_caller_address();\n   let game : Game = game_state.read(game_idx);\n   with_attr error_message (\"a game must exist to join\") {\n       assert_not_zero(game.player_x);\n   }\n\n    with_attr error_message (\"you cannot join the same game\") {\n       assert_not_equal(game.player_x, address);\n   }\n\n   with_attr error_message (\"a spot must be available to join\") {\n       assert game.player_o = 0;\n   }\n\n   let joined_game : Game = Game(game.player_x, address, game.state_x, game.state_o, game.last_mover, game.winner);\n   game_state.write(game_idx, joined_game); \n  player_to_game_idx.write(address, game_idx);\n\n   return (); \n}\nEach role has its own state. The state is encoded into an integer, where the value represents the X or O move on a tictactoe board. Each ‘spot’ on the board (counted from 0 to 8) is treated as power of two.\nWe check for state of each player for a win state by encoding the winning configurations in their representation and ’bitwise_and` the state against a winning state. If the result of that bitwise_and is the winning state, the player has won the game.\nfunc _check_winner{bitwise_ptr: BitwiseBuiltin*}(state: felt, idx: felt, winners: felt*) -> felt {\n    let win_state : felt = [winners];\n    \n    let win_check : felt = bitwise_and(state, win_state);\n\n    %{ print(f\"passing value: {ids.state=} {ids.win_state=} {ids.win_check=}\") %}\n    if (win_check == win_state) {\n       return 1; \n    }\n\n    if (idx == 0) {\n       return (0); \n    } else {\n       let result : felt =  _check_winner(state=state, idx=idx-1, winners=winners+1);\n       return (result); \n    }\n   \n}\n\nfunc check_winner{bitwise_ptr: BitwiseBuiltin*}(state: felt) -> felt {\n    alloc_locals;\n    let winners: felt* = alloc();\n\n    assert winners[0] = 448; \n    // 111 000 000\n    assert winners[1] = 56;\n    // 000 111 000\n    assert winners[2] = 7;\n    // 000 000 111\n    assert winners[3] = 292;\n    // 100 100 100\n    assert winners[4] = 146;\n    // 010 010 010\n    assert winners[5] = 73;\n    // 001 001 001\n    assert winners[6] = 273;\n    // 100 010 001\n    assert winners[7] = 84;\n    // 001010100\n\n    let res : felt = _check_winner(state=state, idx=7, winners=winners);\n    return (res);\n\n}\nThis check_winner logic is part of the overall logic in make_move. We have to safeguard updates of game state for a couple different domains of coherence.\n@external\nfunc make_move{syscall_ptr : felt*, bitwise_ptr: BitwiseBuiltin*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_idx: felt, updated_game_state : felt) {\n   alloc_locals;\n   let address : felt = get_caller_address();     \n   assert_not_zero(address);     \n   let game : Game = game_state.read(game_idx); \n   let role : felt = derive_address_role(game, address);\n   \n    \n    enforce_permissable_move(role, game);\n\n    let (new_game : Game, game_over : felt) = update_game(role, game, updated_game_state);\n\n    game_state.write(game_idx, new_game);   \n    \n    handle_end_game(game_over, address, role, game_idx, new_game);\n    \n\n    return ();\n\n}\nThe first is whether a given agent belongs to the game at all, that is whether they have a role.\nWe need to derive the role of player in the game from address via derive_address_role This function also gives us an error if the actor interacting with the contract doesn’t belong to the denoted game at all:\nfunc derive_address_role(game : Game, address : felt) -> felt {\n    if (address == game.player_x) {\n        return (PLAYER_X);\n    \n    }\n\n    if (address == game.player_o) {\n        return (PLAYER_O);\n        \n    }\n\n   with_attr error_message (\"this player is not registered in this game\") {\n        assert 1 = 0;\n   }    \n   \n   return (0); \n\n}\nThe second domain is the logic of the game itself. Is it the players turn? Is the attempted move coherent with the previous move?\nFirst: in the case the address has a role in the game, we check to see if it is the players turn.\nfunc enforce_permissable_move(role: felt, game: Game) {\n\n   with_attr error_message (\"not your turn\") {\n      assert_not_equal(role, game.last_mover);\n   }\n\n   with_attr error_message (\"game over\") {\n      assert game.winner = 0;\n   }    \n\n    return ();\n}\nAll that safe-guarding of a user and their role within a game, we move into the logic of whether a user with a role in a game has made a valid move and, furthermore, winning move.\nfunc update_game{bitwise_ptr: BitwiseBuiltin*, range_check_ptr}(role : felt, prior_game : Game, new_move :felt) -> (new_game: Game, end_game: felt) {\n    alloc_locals;\n    validate_moves(role, prior_game.state_o, prior_game.state_x, new_move);\n    if (role == PLAYER_X) {\n       let winning_move = check_winner(new_move); \n       let maybe_won = winning_move * role; \n       let new_game = Game(prior_game.player_x, prior_game.player_o, new_move, prior_game.state_o, PLAYER_X, maybe_won);\n       return (new_game=new_game, end_game=winning_move);\n    } else {\n       let winning_move = check_winner(new_move); \n       let maybe_won = winning_move * role;\n       let new_game = Game(prior_game.player_x, prior_game.player_o, prior_game.state_x, new_move, PLAYER_O, maybe_won);\n       return (new_game=new_game, end_game=winning_move);\n    }\n\n}\nThe validate_moves logic derives the difference between the prior board state and the new board state. It needs to discern which role the given agent has.\nfunc validate_moves{bitwise_ptr: BitwiseBuiltin*, range_check_ptr}(role: felt, o_board_state : felt, x_board_state : felt, possible_state : felt) {\n \n    alloc_locals;\n    \n   if (role == PLAYER_X) {\n        let possible_move : felt = possible_state - x_board_state;\n        validate_move(possible_move, o_board_state);\n        tempvar bitwise_ptr=bitwise_ptr;\n        tempvar range_check_ptr=range_check_ptr;\n        \n\n    \n    } else {\n       let possible_move : felt = possible_state - o_board_state;\n       validate_move(possible_move, x_board_state);\n       tempvar bitwise_ptr=bitwise_ptr;\n       tempvar range_check_ptr=range_check_ptr;\n    }\n\n    tempvar bitwise_ptr=bitwise_ptr;\n    tempvar range_check_ptr=range_check_ptr;\n\n\n    // is the one move forward attempting to be made already 'occupied'?\n    // if the move is a valid power of two, take the power and see if it exists in other_role_board_state\n    // if not, we gucci\n\n    return ();\n\n}\nOnce that has been established, it calls into validate_move.\nWe want to maintain that:\n\nthe agent submitted a board state that succeeds the prior (that new_state - old_state) is greater than zero (both not-negative and not-zero\nthat the possible move is a power of two (because we represent each valid position (0-7) as a power of two\nif it is a power of two, we want to make sure the move is within the valid range\nand if it is a valid range, we want to make sure that the spot isn’t already played by either user\n\nIf all that passes, we move on to handle_end_game\nfunc validate_move{bitwise_ptr: BitwiseBuiltin*, range_check_ptr}(possible_move : felt, opposing_board_state : felt, prior_board_state: felt) {\n        alloc_locals;\n        let possible_move_is_not_negative = is_nn(possible_move);\n\n        with_attr error_message (\"board state must succeed prior state\") {\n            assert possible_move_is_not_negative = 1;\n        }\n\n        with_attr error_message (\"board state must change\") {\n           assert_not_zero(possible_move); \n        }\n\n        let valid_possible_move : felt = is_pow_of_two(possible_move);\n    \n        with_attr error_message (\"not a valid discrete move from prior board state\") {\n            // is the delta only one move forward?\n            // for role, is possible_state - role_board_state a power of two?, is so, which power?\n\n            assert valid_possible_move = 1;\n        }    \n\n        // for role, is possible_state - role_board_state a power of two?, is so, which power?\n        let (local move_on_board) = log2(possible_move, 8, -1);\n\n        with_attr error_message (\"move is not on the board\") {\n            // is the delta only one move forward?\n            // for role, is possible_state - role_board_state a power of two?, is so, which power?\n\n           assert_not_equal(move_on_board, -1);\n        }\n\n        // did the other player already make a move in that spot?\n        let move_is_taken : felt = get_nth_bit(opposing_board_state, move_on_board);\n       %{ print(f\"move check: {ids.possible_move=} {ids.move_on_board=} {ids.opposing_board_state=} {ids.move_is_taken=} \") %}\n\n        with_attr error_message (\"move is already taken by opposition\") {\n            // is the delta only one move forward?\n            // for role, is possible_state - role_board_state a power of two?, is so, which power?\n\n           assert_not_equal(move_is_taken, 1);\n        }\n\n        // did the current player already make a move in that spot?\n        let prior_move_is_taken : felt = get_nth_bit(prior_board_state, move_on_board);\n\n        with_attr error_message (\"move is already made by yourself\") {\n            // is the delta only one move forward?\n            // for role, is possible_state - role_board_state a power of two?, is so, which power?\n\n           assert_not_equal(prior_move_is_taken, 1);\n        }\n\n    return ();\n}\n\nThe handle_end_game function releases a player from being associatted with completed games, as well as emiting a game over event. The tempvar stuff is incidental complexity in the cairo vm involving how it tracks references (perhaps to be expanded in another post).\nfunc handle_end_game{ syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr}(game_ended : felt, maybe_winner : felt, maybe_winner_role : felt, game_id : felt, game : Game) {\n    if (game_ended == 0) {\n    tempvar syscall_ptr=syscall_ptr;\n    tempvar pedersen_ptr=pedersen_ptr;\n    tempvar range_check_ptr=range_check_ptr;\n    \n    } else {\n    player_to_game_idx.write(game.player_x, 0);\n    player_to_game_idx.write(game.player_o, 0);\n    game_over.emit(game_id=game_id, role=maybe_winner_role, winner=maybe_winner);\n    tempvar syscall_ptr=syscall_ptr;\n    tempvar pedersen_ptr=pedersen_ptr;\n    tempvar range_check_ptr=range_check_ptr;    \n    \n    } \n\n    \n    return ();\n}\nThe game_over event gives a client a way to know that a given move ends the game. This happens when a user submits a transaction and we query for a receipt of the transaction. Events are communicated in the receipt of transactions and obtusely look something like this:\n{\"execution_resources\": {\"n_memory_holes\": 46, \"n_steps\": 1036, \"builtin_instance_counter\": {\"pedersen_builtin\": 4, \"range_check_builtin\": 15, \"bitwise_builtin\": 6, \"ecdsa_builtin\": 1}}, \"actual_fee\": \"0x4052f28072000\", \"block_hash\": \"0x11\", \"block_number\": 17, \"events\": [{\"keys\": [\"0xdabba9ce03ade36611d5d401193a84cd9e1d9ee37a87ce9bbab55690fcfae0\"], \"from_address\": \"0x2a21ef6a5f000e6647857c88b46a66c54df282d88ca6be7d86079672e5f51b4\", \"data\": [\"0x1\", \"0x1\", \"0x38aa61d589ed7010703ec364fa37a474b7c66b4079579ff472d65731919dfdf\"]}, {\"keys\": [\"0x99cd8bde557814842a3121e8ddfd433a539b8c9f14bf31ebf108d12e6196e9\"], \"from_address\": \"0x62230ea046a9a5fbc261ac77d03c8d41e5d442db2284587570ab46455fd2488\", \"data\": [\"0x38aa61d589ed7010703ec364fa37a474b7c66b4079579ff472d65731919dfdf\", \"0x388ca486b82e20cc81965d056b4cdcaacdffe0cf08e20ed8ba10ea97a487004\", \"0x4052f28072000\", \"0x0\"]}], \"status\": \"ACCEPTED_ON_L2\", \"transaction_index\": 0, \"transaction_hash\": \"0x2e1d29606ae45b8ed95b598a20e337bea7a9ac92fae6dde10527daab4a1ee14\", \"l2_to_l1_messages\": []}\nThe ‘keys’ of events can be derived like so:\n\nselector_name = starknetjs.hash.getSelectorFromName(\"game_over\");\nselector_name;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nviewing a conttract\nThe view logic here might be a little too complex. Essentially it is one render loop that uses observablehq primitives. We get the state of a given game, the client state of the view, and pass it to render logic. If we have a pendingTxn in state, we get the receipt, then rerender, or we just wait 3 seconds and rerender.\n\nasync function* renderGame() {\n  const viewState = createState();\n  var contractState = [starknetjs.number.toBN(0), {}, -1];  \n  while (true) {\n    let body = null;\n    \n    const p = new Promise(async (resolve) => {\n      console.log(\"about to render\", contractState, viewState);\n      body = renderGrid(contractState, viewState, resolve);\n      contractState = await fetchContractState();\n      if (contract) {\n      \n      if(viewState.pendingTxn) {\n      \n         await handleTxn(viewState)  \n         resolve() \n      \n      } else {\n      \n      await Promises.delay(3000);\n      resolve();\n      \n      }\n      }\n    });\n\n    yield body;\n\n    await p;\n  }\n}\n\n\n\n\n\n\n\nasync function handleTxn(state) {\n    let txnHash = state.pendingTxn.transaction_hash;\n    let receipt =  await wallet.provider.getTransactionReceipt(txnHash);\n    if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {\n\n        state.pendingTxn = null;\n        // state.txnState = null;\n    \n    } else {\n    \n        state.txnState = receipt;\n        console.log(receipt);\n    \n    }\n    \n\n\n}\n\n\n\n\n\n\n\nfunction renderBox(contractState, cr, cellValue, onClick) {\n     let boardState = contractState[1];\n     let xState = boardState.state_x;\n     let oState = boardState.state_o;\n     let binaryRep = cr_to_binary(cr[0], cr[1]);\n     let maybeX = xState & binaryRep;\n     let maybeO = oState & binaryRep;\n\n    if (maybeX == binaryRep) {\n        cellValue = 1;\n    }\n    if (maybeO == binaryRep) {\n        cellValue = 2;\n    }\n \n\n \n  \n  const box = html`\n    <div\n      style=\"\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: 100px;\n        height: 100px;\n        border: 2px black solid;\n        user-select: none;\n      \">\n     <div style=\"font-size: 5em\">${charLut[cellValue]}</div>\n  </div>`;\n\n  box.addEventListener(\"click\", onClick);\n\n  //render box cares not about what the clicking does\n  return box;\n}\n\n\n\n\n\n\n\nfunction boardStateForRole(role, contractState) {\n    let boardState = undefined;\n    if (role == 1) {\n    \n        boardState = contractState.state_x\n        \n    } else if (role == 2) {\n    \n        boardState = contractState.state_o\n    \n    }\n    \n    return boardState;\n}\n\n\n\n\n\n\n\ntxnView = (contractState, viewState) => {\n    if (viewState.pendingTxn) {\n    \n    return html`<div>Txn: ${viewState.pendingTxn.transaction_hash} Current status: ${viewState.txnState ? viewState.txnState.status : \"pending\"}</div>`\n    \n    } else {\n    \n      return \"\";  \n    }\n}\n\n\n\n\n\n\n\nturnView = (contractState, viewState) => {\n    let ourTurn = contractState[3];\n    return html`<div>${ourTurn ? \"Your turn.\" : \"Their turn\"}</div>`\n\n}\n\n\n\n\n\n\n\nrenderGrid = (contractState, state, onChange) => {\n  let button = html`<button>Submit move</button>`\n\n  let submitMove = async (e) => {\n     let gameId = contractState[0].toNumber();\n     let role = contractState[2];\n     let moveToSubmit = state.my_potential_move[0];\n     let boardState = boardStateForRole(role, contractState[1]); \n     let playerTotalBoardState = moveToSubmit + boardState;\n     let txn = await contract.make_move(gameId, playerTotalBoardState);\n     state.pendingTxn = txn\n     onChange();\n  }\n  button.addEventListener(\"click\", submitMove)\n  \n  let txnViewer = txnView(contractState, state);\n  return html`\n  <div style=\"display:flex; flex-direction: column; justify-content: center; align-items: center;\">\n    <h1 style=\"font-size: 5em;color: red\">Tic-Tac-Toe</h1>\n    <h2> Winner is ${charLut[state.winner]}</h2> \n    <h4>Current Game Id : ${contractState[0].toNumber()}</h2>\n    ${button}\n    ${txnViewer}\n    ${turnView(contractState, state)}\n    <div style=\"\n      display:inline-flex;\n      justify-content: center;\n      align-items: center;\n      border: 2px solid black;\n    \">${d3.range(GRID_WIDTH).map((row) => {\n      return html`<div>${d3.range(GRID_HEIGHT).map((col) =>\n        renderBox(contractState, [col, row], state.board[col][row], () => {\n          handleTurn(contractState, state, col, row); \n          onChange();\n          //}\n        })\n      )}`;\n    })}\n    </div>\n  </div>`\n  }\n\n\n\n\n\n\n\nfunction cr_to_binary(col, row) {\n    var increase;\n    switch (col) {\n        case 0: \n            increase = 0;\n            break;\n        case 1:\n            increase = 3;\n            break;\n        case 2:\n            increase = 6\n;\n\n    }\n    \n    var binary_idx = row + increase;\n    return Math.pow(2, binary_idx);\n}\n\n\n\n\n\n\n\nfunction handleTurn(contractState, state, col, row) {\n  let role = contractState[2];\n\n  if (state.board[col][row] === 0) {\n      state.board[col][row] = role;\n      state.my_potential_move = [ cr_to_binary(col, row)  , [col, row] ]\n\n\n    state.turn++;\n    // winGame(state);\n    console.log(state, col, row);\n  } else {\n    let bival = state.my_potential_move[0];\n    let [p_c, p_r] = state.my_potential_move[1]\n    if (p_c == col && p_r == row) {\n    state.my_potential_move = null;\n    state.board[col][row] = 0;\n     \n     }\n\n  }\n}\n\n\n\n\n\n\n\ncharLut = [\"\", \"X\", \"O\", \"neither\"]\n\n\n\n\n\n\n\ncreateState = () => {\n  const board = d3\n    .range(GRID_HEIGHT)\n    .map(() => d3.range(GRID_WIDTH).map(() => 0));\n  //state[2][2] = 1;\n  return { board, turn: 0, winner: 0, x_player_state: 0, o_player_state: 0, my_potential_move: null, pendingTxn: null, txnState: null };\n}\n\n\n\n\n\n\n\nGRID_WIDTH = 3\nGRID_HEIGHT = 3\nX_PLAYER = 1\nX_PLAYER_STATE = 0\nO_PLAYER = 2\nO_PLAYER_STATE = 0\nNEITHER = 3"
  },
  {
    "objectID": "posts/0_hello_wallet/index.html",
    "href": "posts/0_hello_wallet/index.html",
    "title": "hello, wallet",
    "section": "",
    "text": "incredible counting on internet computers\nI’ll start with a brief little ‘how to’ guide of building a ui that can ‘reach out’ to a browser extension wallet and then ‘do things with’ a contract on starknet. If you think some other technology is way better than starknet, take a deep breath and treat this as me simply using one instance of the general class of internet computers. Then, in a following section, I’ll try to probe some of the theory of how that is happening.\nThere is a little bit of incidental detail that I’ll ellide here, as I am using Quarto which (in turn) lets me use observable for computation. We can kind of squint and treat it as ‘just’ javascript and I’ll defer all the details on how it isn’t to the creators here.\nWe will see how well observable plays with contract interop. Here we only break a little ground and in subsequent iterations.\nSo we start by pulling in starknetjs and get_starknet\n\nstarknetjs = import(\"https://jspm.dev/starknet\")\nget_starknet = import(\"https://jspm.dev/get-starknet\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThen we write a async function that uses get_starknet to display to a user an interface for selecting and consenting a wallet and a given account to a session.\n\nasync function connectWallet(e)  {\n   var wallet =  await get_starknet.connect();\n   await wallet.enable();\n   return wallet;\n}\n\n\n\n\n\n\nAnd consider this some boiler plate for observable to give me a little button view that, on clicked, will present aforementioned wallet interface.\n\nwallet ? md`${wallet.selectedAddress}, you achieved things. You pushed through. You did it.` : md`Come on. All you need to do is install a browser plugin. You can do it.`\n\n\n\n\n\n\n\nviewof wallet = Inputs.button(\"Connect\", {value: null, reduce: connectWallet})\n\n\n\n\n\n\nIf you had the audacity to push through the resistance and actually install a browser plugin wallet, you can see that its object unifies a couple of abstractions we will get into in the question of how a client and contract on a chain interact: account and provider\n\nwallet\n\n\n\n\n\n\nWith a wallet, we can construct an interface to a contract that ‘lives’ on a chain. We also need said contracts abi which is the contract’s application binary interface and the contracts address.\nThe abi is constructed when you compile a cairo contract and the address is generated from the deployment of a contract to a chain.\n\ncontract = {\nvar abi = await FileAttachment(\"../counter_abi.json\").json()\nreturn wallet ? (new starknetjs.Contract(abi, \"0x036486801b8f42e950824cba55b2df8cccb0af2497992f807a7e1d9abd2c6ba1\", wallet.account)) : null\n\n}\n\n\n\n\n\n\nHere we call a view method, basically reading state from the contract. Observable has some magic that lets me treat promises like regular statements, but everything ‘across’ the contract interaction is asynchronous.\n\ncount = contract.counter()\n\n\n\n\n\n\n\ncontract ? md`${count} is the count` : null\n\n\n\n\n\n\nIncrement counter mutates the contract state.\n\nasync function callIncrement(e)  {\n   var txn = await contract.incrementCounter(1);\n   return txn;\n}\n\n\n\n\n\n\nInvoking it gives us an object with a transaction hash.\n\nviewof incrementTxn = Inputs.button(\"increment\", {value: null, reduce: callIncrement})\n\n\n\n\n\n\nWhat’s going on? What’s happening? What is this magic?\n\nincrementTxn\n\n\n\n\n\n\n\nasync function* pollTxn(tx, timeout) {\n while(true) {\n  var last_response; \n  let receipt = await wallet.provider.getTransactionReceipt(tx.transaction_hash)\n  console.log(receipt);\n  if (receipt.status == 'REJECTED' || receipt.status == 'ACCEPTED_ON_L2') {\n    return receipt;\n  } else {\n    last_response = receipt;\n    await Promises.delay(timeout);\n    if (last_response.status != receipt.status) {\n    yield receipt;\n    }\n   ;\n  }\n  }  \n}\n\n\n\n\n\n\n\ntxnTracker = pollTxn(incrementTxn, 10000);\n\n\n\n\n\n\n\ntxnTracker\n\n\n\n\n\n\n\ncontract\n\n\n\n\n\n\n\n\ncommunication between users, applications, blockchains\nA wallet gives a user an account on a given blockchain. But implicitly it offers a way for users to communicate with it.\nHow?\nLet’s investigate our wallet object again.\n\nwallet\n\n\n\n\n\n\nWhat are these attributes of account and provider?\nA provider lets you interact with the network without signing transactions, which basically means it gives you read access.\nWhen we want write access, we communicate with our account to, in Starknet’s case, the sequencer node.\nBut how is this communication done?\nWe can be so bold as to look at starknetjs source and see that the provider object using an rpc protocol against the provider endpoint.\nSame deal with the sequencer, but it also seems that some functionality is exposed as http endpoints, i.e. callContract\nSo let’s try to follow what is happening when a user interacts with a contract on a web client.\nEssentially, starknet-js takes ownership of coordinating users to the right remote calls. In a mature blockchain ecologies, the remote calls are to an open class of processes, where processes can perform certain roles like having access to the full history of blockchain transactions or simply accepting/relaying transactions and participating in consensus.\nSo when I click the increment button and get back a transaction hash, the user’s action/agency is given an identifiable ticket in a queue of transactions that need to make it to a block for it to be finalized.\nA couple things stand out–one, is that ‘reads’ from a contract need to have some awareness of the state of users transactions of the contract at the very least, let alone the possible transactions of other users. This is something I’ll explore in subsequent posts.\nI am still unsure how well observablehq’s reactive constructs will play with ‘hooking’ into a blockchain contracts. The allure of starting out with it is offers me more joy than the full gamut react or whatever hell else is popular in js land.\nWe will see if there’s a hard limit.\nAnother is, having had a little experience with the early nft wave of Solana, when you are so lucky to have a ‘surge’ of users trying to submit transactions against the same node/rpc, you aren’t going to have a good time. There were a lot of cases of quiet failure.\nSo the question of the best of all ways to provide your users the smoothest experience with a blockchain might involve a little devops.\nOnward."
  }
]